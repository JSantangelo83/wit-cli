#!/bin/bash

wit_yaml="/etc/wit-cli/wit.yaml"

trap 'exit 1' TERM

info()  { echo -e "\e[32m[+] $1\e[0m"; }
warn()  { echo -e "\e[33m[!] $1\e[0m"; }
error() {
    set +e
    echo -e "\e[31m[-] $1, exiting...\e[0m" >&2
    kill -s TERM "$$";
}

check_dependencies() {
    local missing=()
    local dependencies=("yq")

    for cmd in "${dependencies[@]}"; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
            missing+=("$cmd")
        fi
    done

    if [ "${#missing[@]}" -gt 0 ]; then
        warn "The following required command(s) are missing:"
        for cmd in "${missing[@]}"; do
            echo "  - $cmd"
        done
        error "Cannot run without all dependencies"
    fi
}

get_port() {
    while :; do
        port=$(shuf -i 2000-65000 -n 1)
        if ! ss -tuln | awk '{print $5}' | grep -q ":$port\$"; then
            echo "$port"
            return
        fi
    done
}

help() {
    echo "Usage: $(basename $0) [COMMAND | OPTION] [ARGS...]"
    echo
    echo "Commands and Options:"
    echo "  install       --install, -i [services...] Install one or more services"
    echo "  init       --init, -n [path] [port] Creates default config files for a new service (uses the directory name as service name)"
    echo "  help          --help,    -h           Show this help message"
    echo
    echo "Examples:"
    echo "  $(basename $0) install service1 service2"
    echo "  $(basename $0) -i service1"
    echo "  $(basename $0) init ./service2 1234"
    echo "  $(basename $0) -n service2 1234"
}

init(){
    path="$(realpath "${1:-.}")"
    service_name="$(basename $path)"
    port="${2:-$(get_port)}"

    # Create the default service if not exists
    if ! [[ -f "$path/$service_name.service" ]]; then
        cat <<EOF > "$path/$service_name.service"
[Unit]
Description=Wit Service ($service_name)
After=network.target

[Service]
User=$USER
WorkingDirectory=%h/$service_name
ExecStart=/usr/bin/docker compose --project-directory %h/$service_name up
ExecStop=/usr/bin/docker compose --project-directory %h/$service_name down
Restart=always

[Install]
WantedBy=multi-user.target
EOF
fi

    fi

    # Creates the default wit.conf if not exists
    if ! [[ -f wit.conf ]]; then
        cat <<EOF > "$path/wit.conf"
dns=$service_name
service=./$service_name.service
port=$port
#name="Some Name"
#description="Some Description"
EOF
    fi

    # Creates the default docker-compose.yml if not exists
    if ! [[ -f docker-compose.yml ]]; then
        cat <<EOF > "$path/docker-compose.yml"
version: '3.8'

services:
  $service_name:
    build:
      context: .
    ports:
      - "$port:$port"
    container_name: $service_name
    restart: unless-stopped
EOF
    # Creates default Dockerfile
    cat <<EOF > "$path/Dockerfile"
# Here goes your dockerfile instructions
EOF
    fi
}

export -f init;

install(){
    service="$1"
    config_path="$2"

    if ! [ -n "$service" ]; then
        help;
        exit 1;
    fi

    giturl="$(yq -r ".services[\"$service\"].giturl" $wit_yaml)"
    reponame=$(echo "$giturl" | grep -oE '[^/]+\.git$' | sed 's/\.git$//')

    if ! [ -n "$giturl" ]; then
        error 'Service not found';
    fi

    user="$service"

    # Create user if it doesn't exist
    if ! id "$user" >/dev/null 2>&1; then
        info "Creating user: $user"
        sudo useradd -m "$user"
        echo -e "root\nroot" | (sudo passwd "$user")
    else
        warn "User $user already exists"
    fi

    # Ensure user is in required groups
    # Done like this for better scalability
    for group in docker; do
        if ! id -nG "$user" | grep -qw "$group"; then
            info "Adding $user to $group group"
            sudo usermod -aG "$group" "$user"
        fi
    done

    home="/home/$user"

    # Install ssh key if it doesn't exist
    if ! sudo -u "$user" test -f "$home/.ssh/id_rsa"; then
        info "Generating SSH key for $user"
        sudo -u "$user" -H mkdir -p "$home/.ssh"
        sudo -u "$user" -H ssh-keygen -t rsa -b 2048 -f "$home/.ssh/id_rsa" -N "" -q

        info 'Public key:'
        sudo -u "$user" -H cat "$home/.ssh/id_rsa.pub"

        echo -e "\nPress Enter after you added the key as a Deploy Key on Github..."
        read
    else
        warn "SSH key already exists for $user"
    fi

    # Clone repo
    if [ ! -d "$home/$reponame/.git" ]; then
        info "Cloning $giturl"
        sudo -u "$user" -H git clone "$giturl" "$home/$reponame"
    else
        warn "Repo already exists: $home/$reponame"
    fi

    # Import conf file
    dns="$reponame"
    service="$reponame.service"
    port="$(get_port)"
    name="$reponame"
    description=""

    # Load overrides from file if it exists
    conf_file="$home/$reponame/wit.conf"
    if [ -f "$conf_file" ]; then
        # shellcheck source=/dev/null
        source "$conf_file"
    else
        warn "Config file not found: $conf_file. Using defaults."
        sudo -u "$user" -H bash -c "$(declare -f init);$(declare -f get_port); init '$home/$reponame'"
    fi

    # Ensuring systemd available on each terminal
    line="export XDG_RUNTIME_DIR=/run/user/$(id -u "$user")"
    if ! sudo -u "$user" grep -Fxq "$line" "$home/.bashrc"; then
        info "Adding XDG_RUNTIME_DIR export to bashrc"
        echo "$line" | sudo -u "$user" -H tee -a "$home/.bashrc" > /dev/null
    fi

    # Ensuring alias for systemctl --user exists
    alias_line="alias sctl='systemctl --user'"
    if ! sudo -u "$user" grep -Fxq "$alias_line" "$home/.bashrc"; then
        info "Adding 'sctl' alias to bashrc"
        echo "$alias_line" | sudo -u "$user" -H tee -a "$home/.bashrc" > /dev/null
    fi


    # Install and run service
    service_name="$(basename "$service")"
    user_systemd_dir="$home/.config/systemd/user"

    sudo loginctl enable-linger "$user"

    uid=$(id -u "$user")
    userenv=(sudo -u "$user" env XDG_RUNTIME_DIR="/run/user/$uid")

    # ensure the user systemd instance is running
    "${userenv[@]}" systemd-run --user --scope true >/dev/null 2>&1

    if ! "${userenv[@]}" test -f "$user_systemd_dir/$service_name"; then
        info "Installing systemd service for $user"
        "${userenv[@]}" mkdir -p "$user_systemd_dir"
        "${userenv[@]}" cp "$home/$reponame/$service" "$user_systemd_dir/"
        info "Reloading user systemd daemon"
        "${userenv[@]}" systemctl --user daemon-reload
    else
        warn "Service already installed: $user_systemd_dir/$service_name"
    fi

    if ! "${userenv[@]}" systemctl --user is-enabled "$service_name" >/dev/null 2>&1; then
        info "Enabling service $service_name"
        if ! "${userenv[@]}" systemctl --user enable "$service_name" &> /dev/null; then
            error "Failed to enable service: $service_name"
        fi
    else
        warn "Service $service_name already enabled"
    fi

    if ! "${userenv[@]}" systemctl --user is-active "$service_name" >/dev/null 2>&1; then
        info "Starting service $service_name"
        if ! "${userenv[@]}" systemctl --user start "$service_name"; then
            warn "Cannot start service"
            echo "[i] Service status:"
            "${userenv[@]}" systemctl --user status "$service_name"
            error "Failed to start service"
        fi
    else
        warn "Service $service_name already running"
    fi

    # Check if the hostname is already present in the ingress list
    if ! sudo yq -e ".ingress[] | select(.hostname == \"$dns.witjt.org\")" /etc/cloudflared/config.yml >/dev/null; then
        info "Adding entry to /etc/cloudflared/config.yml"
        sudo yq -y -i '
        .ingress |= ((.[0:-1]) + [{"hostname": "'$dns'.witjt.org", "service": "http://localhost:'$port'"}] + [.[-1]])
        ' /etc/cloudflared/config.yml
    else
        warn "Entry for $dns.witjt.org already exists in config.yml"
    fi
    
    if ! cloudflared tunnel route dns wit-shared "$dns.witjt.org" 2>&1 | grep -q "already configured"; then
        info "Adding route dns to 'wit-shared' tunnel"
        sudo cloudflared tunnel route dns wit-shared "$dns.witjt.org" > /dev/null 2>&1
        
        info "Restarting cloudflared service"
        sudo systemctl restart cloudflared
    else
        warn "Route dns on 'wit-shared' tunnel already created"
    fi

}

check_dependencies;

case "$1" in
    update|-u|--update)
        update
        ;;
    install|-i|--install)
        shift
        install "$@"
        ;;
    init|-n|--init)
        shift
        init "$@"
        ;;
    help|-h|--help|"")
        help
        ;;
    *)
        echo "Unknown command: $1"
        help
        exit 1
        ;;
esac
